spring.application.name=BoardBackend

# 서버 포트 : 기본포트(8080) -> 8000(변경)
server.port=8000
# 자바 소스가 수정되면 서버 자동 재시작을 함
spring.devtools.restart.enabled=true

## TODO: DB 라이브러리 설정 : build.gradle 오라클 db 라이브러리 없으면 에러발생
#spring.datasource.driver-class-name=net.sf.log4jdbc.sql.jdbcapi.DriverSpy
## TODO: DB 접속 설정  : 도커 오라클 , 계정/암호, db명(서비스이름)(xepdb1)
### todo: spring.datasource.url=jdbc:log4jdbc:oracle:thin:@ip주소:db포트번호/db이름
#spring.datasource.url=jdbc:log4jdbc:oracle:thin:@localhost:1521/xepdb1
## 계정 정보
#spring.datasource.username=scott
## 암호
#spring.datasource.password=!Ds1234567890

# 오라클 설정 ( 오라클 클라우드 전자지갑 설정 ) : log4j 적용
spring.datasource.driver-class-name=net.sf.log4jdbc.sql.jdbcapi.DriverSpy
# jdbc:log4jdbc:oracle:thin:@orcl_low?TNS_ADMIN=전자지갑경로
spring.datasource.url=jdbc:log4jdbc:oracle:thin:@orcl_low?TNS_ADMIN=C:/Wallet_orcl
spring.datasource.username=lotto2
spring.datasource.password=!Ds1234567890

# DB접속수 제한 : 1사람당 1개
spring.datasource.hikari.minimumIdle=1
spring.datasource.hikari.maximumPoolSize=1
spring.datasource.hikari.poolName=HikariPoolBooks


# TODO: JPA 접속 설정
# JPA : sql 를 자동 생성해주는 프레임워크 :
# => JPA 기본함수만 실행하면 해당되는 sql 문을 만들어줌(자동화기능)
# => JPA 복잡한 sql 문은 개발자 직접 작성하는 기능이 있음 => Querydsl 라이브러리
# vs Mybatis : 모든 sql 을 개발자 직접 작성하는 방식, 대신에 작성시 가독성 높여서 작성가능


# JPA : sql 자동작성 기능 : 1) ddl (테이블생성, 시퀀스 생성등) 생성           : x
#                         2) dml (CRUD:insert/select/update/delete) 생성 : O
# ddl 자동생성 기능 켜기 옵션 : none(끄기), create(켜기), update(없는것만 만들기)
spring.jpa.hibernate.ddl-auto=none
# todo: db 제품 연결 ( oracle 12이상 : Oracle12cDialect )
spring.jpa.database-platform=org.hibernate.dialect.Oracle12cDialect


# batch size 설정 : 연관관계 설정 시 N+1 문제 최소화
#  여러 개의 SELECT 쿼리들을 하나의 IN 쿼리로 만들어줍
spring.jpa.properties.hibernate.default_batch_fetch_size=1000


# TODO: 업로드 파일 사이즈 제한 설정 : 기본(1MB 까지)
#  file upload size 설정
spring.servlet.multipart.max-file-size=1MB
spring.servlet.multipart.max-request-size=1MB

# todo : 카프카 접속 설정
# consumer bootstrap servers가 따로 존재하면 설정
#spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.bootstrap-servers=kafka:9092

# 식별 가능한 Consumer Group Id -> 소비자 그룹 이름 설정
spring.kafka.consumer.group-id=academy

# 오프셋 -> 소비자가 읽은 메세지를 표시해두는 것 -> 이걸 해줘야 중복 전송을 막을 수 있다.
# 설정 : earliest(오래된) / latest(최근), 최초설정이나 갑자기 장애등의 이유로 사라졌을경우 설정을 해주어야한다.
spring.kafka.consumer.auto-offset-reset=earliest


# 데이터를 받아올 때, key/value 를 역직렬화 : json 에서 (key, value) 로  변경시 변환 설정
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer


# producer bootstrap servers 가 따로 존재하면 설정 :(key, value) 에서 json 으로  변경시 변환 설정
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer


# TODO: 웹토큰(JWT) 설정 : 비밀키, 만료시간(10분)
#  openssl rand -hex 64 : git bash 또는 리눅스에서 실행하면 랜덤한 64 byte 비밀키 생성됨
simpleDms.app.jwtSecret=bd1889daea6ad98b6e099034b0544974a17bab50c2872e3916c6c7d7762ce80fe9bc0a72ea5d62e65eb7e2396d6dcd1fb90937c7ead79adce142c8383de20776
# 만료시간 : 밀리세컨드
# 10분
simpleDms.app.jwtExpirationMs= 6000000

# TODO : Kakao OAuth2 설정
kakao.client-id=6a9b8daaeef2609b3db2849d027f6080
kakao.redirect-uri=http://localhost:8080/auth-redirect
kakao.client-secret=U4FeBBFQhFNqWAMa8o27f5kwrctXSxed
## rest API 앱키
#spring.security.oauth2.client.registration.kakao.client-id=6a9b8daaeef2609b3db2849d027f6080
## 시크릿 키
#spring.security.oauth2.client.registration.kakao.client-secret=cjkDu1RxQ02TGHg0uqSp5INsXrkY6mVH
## redirect uri 주소
#spring.security.oauth2.client.registration.kakao.redirect-uri=https://localhost:8000/auth-redirect/kakao
#spring.security.oauth2.client.registration.kakao.authorization-grant-type=authorization_code
#spring.security.oauth2.client.registration.kakao.client-authentication-method=client_secret_post
## 가져올 정보 권한 범위
#spring.security.oauth2.client.registration.kakao.scope=id

# TODO: 레디스 DB 접속정보
# TODO: 스프링에서 지원하는 속성 아님, 개발자가 만든 것
redis.host=localhost
redis.port=6379
